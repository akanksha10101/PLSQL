ðŸ”¹ Introduction â€“ Why Analyze PL/SQL Code?

                    PL/SQL developers often need to answer key questions about their codebase:
                    On which database objects does my program depend?
                    Which packages call subprograms or global variables in others?
                    Are any subprograms using discouraged data types?
                    Are all subprograms compiled with the right optimization settings?
                    Simple text search (in IDEs) is not sufficient for deep code analysis.
                    Oracle Database provides a Data Dictionary â€” a rich set of views that can answer these questions using SQL queries.

ðŸ”¹ Data Dictionary Overview

                    The data dictionary is a collection of views and tables that describe all database objects.
                    Users typically have SELECT privileges on specific dictionary views.
                    
                    Three common view prefixes:
                              USER_ â†’ Objects owned by the current user.
                              ALL_ â†’ Objects accessible to the user.
                              DBA_ â†’ All database objects (requires DBA privileges).

ðŸ”¹ Core Dictionary Views for PL/SQL Developers
                  View Name              	Purpose
                  USER_ARGUMENTS	                     Lists parameters (name, mode, datatype) of procedures/functions.
                  USER_DEPENDENCIES	                       Shows object dependencies (who depends on what).
                  USER_ERRORS	                         Displays compilation errors for owned objects.
                  USER_IDENTIFIERS	                  Lists identifiers (variables, functions, etc.) in source code â€“ populated by PL/Scope.
                  USER_OBJECT_SIZE      	              Shows size details (source, parsed, compiled) of PL/SQL objects.
                  USER_OBJECTS	                           Lists all owned objects, their type, status, and modification time.
                  USER_PLSQL_OBJECT_SETTINGS	            Provides compiler settings (optimization level, warnings, etc.) for each PL/SQL object.
                  USER_PROCEDURES	                         Metadata about procedures/functions (AUTHID, DETERMINISTIC, PIPELINED, etc.).
                  USER_SOURCE	                             Contains the text source code of all owned PL/SQL objects.
                  USER_STORED_SETTINGS	                   Displays PL/SQL compiler flag settings.
                  USER_TRIGGERS, USER_TRIGGER_COLS	       Show trigger definitions, events, and columns involved.

ðŸ”¹ Example Queries for Each View
ðŸ§© USER_OBJECTS

                  Show all tables:
                  
                  SELECT object_name FROM user_objects
                   WHERE object_type = 'TABLE'
                   ORDER BY object_name;
                  
                  
                  Find invalid objects:
                  
                  SELECT object_type, object_name
                    FROM user_objects
                   WHERE status = 'INVALID';
                  
                  
                  Show objects modified today:
                  
                  SELECT object_type, object_name, last_ddl_time
                    FROM user_objects
                   WHERE last_ddl_time >= TRUNC(SYSDATE);

ðŸ§© USER_SOURCE

                  Search code references (e.g., calls to SALES_MGR.CALC_TOTALS):
                  
                  SELECT name, line, text
                    FROM user_source
                   WHERE UPPER(text) LIKE '%SALES_MGR.CALC_TOTALS%'
                   ORDER BY name, line;
                  
                  
                  Useful for finding:
                  
                  Procedure calls
                  Violations of naming/coding standards
                  Literal values needing replacement

ðŸ§© USER_PLSQL_OBJECT_SETTINGS

Find programs with low optimization levels:

SELECT name
  FROM user_plsql_object_settings
 WHERE plsql_optimize_level < 2;


Find objects with compiler warnings disabled:

SELECT name, plsql_warnings
  FROM user_plsql_object_settings
 WHERE plsql_warnings LIKE '%DISABLE%';

ðŸ§© USER_PROCEDURES

Invoker rights procedures:

SELECT object_name, procedure_name
  FROM user_procedures
 WHERE authid = 'CURRENT_USER';


Deterministic functions:

SELECT object_name, procedure_name
  FROM user_procedures
 WHERE deterministic = 'YES';

ðŸ§© USER_TRIGGERS

Find disabled triggers:

SELECT * FROM user_triggers WHERE status = 'DISABLED';


Find row-level triggers on EMPLOYEES:

SELECT * FROM user_triggers
 WHERE table_name = 'EMPLOYEES'
   AND trigger_type LIKE '%EACH ROW';


Find triggers that fire on UPDATE:

SELECT * FROM user_triggers
 WHERE triggering_event LIKE '%UPDATE%';


âš ï¸ Note: TRIGGER_BODY is of type LONG, so it cannot be searched directly with LIKE.

Instead, use PL/SQL to loop through and analyze bodies.

ðŸ§© USER_DEPENDENCIES

Find objects depending on EMPLOYEES table:

SELECT type, name
  FROM user_dependencies
 WHERE referenced_name = 'EMPLOYEES';


Find dependencies of ORDER_MGR package:

SELECT referenced_type, referenced_name
  FROM user_dependencies
 WHERE name = 'ORDER_MGR'
   AND referenced_owner = USER;


Best Practice Check:
Identify all non-_API program units that contain SQL directly:

SELECT name, type, referenced_name
  FROM user_dependencies
 WHERE referenced_type = 'TABLE'
   AND name NOT LIKE '%\_API' ESCAPE '\';

ðŸ§© USER_ARGUMENTS

Find programs with LONG datatype parameters:

SELECT object_name, package_name, argument_name
  FROM user_arguments
 WHERE data_type = 'LONG';


Find functions using OUT or IN OUT parameters:

SELECT ua.object_name, ua.package_name, ua.argument_name, ua.in_out
  FROM (SELECT * FROM user_arguments WHERE position = 0) funcs,
       user_arguments ua
 WHERE ua.in_out IN ('OUT', 'IN OUT')
   AND ua.position > 0
   AND ua.data_level = 0
   AND funcs.object_name = ua.object_name
   AND funcs.package_name = ua.package_name
   AND (funcs.overload = ua.overload
     OR (funcs.overload IS NULL AND ua.overload IS NULL));


Functions should ideally have only IN parameters (for SQL usability and function-based indexing).

ðŸ”¹ PL/Scope: Advanced Code Analysis (Introduced in Oracle 11g)

               PL/Scope gathers detailed information about identifiers (variables, constants, exceptions, etc.).

                Populates USER_IDENTIFIERS view.

Enables deep analysis, e.g.:

Finding declared-but-unused variables or exceptions.

Understanding code structure without manual parsing.

Example â€“ Find Unused Exceptions:

WITH subprograms_with_exception AS (
  SELECT DISTINCT owner, object_name, object_type, name
    FROM all_identifiers
   WHERE owner = USER
     AND usage = 'DECLARATION'
     AND type = 'EXCEPTION'
),
subprograms_with_raise_handle AS (
  SELECT DISTINCT owner, object_name, object_type, name
    FROM all_identifiers
   WHERE owner = USER
     AND usage = 'REFERENCE'
     AND type = 'EXCEPTION'
)
SELECT * FROM subprograms_with_exception
MINUS
SELECT * FROM subprograms_with_raise_handle;


âž¡ Identifies exceptions declared but never referenced.

ðŸ”¹ Key Takeaways

âœ… Use data dictionary views to automate PL/SQL code analysis and improve maintainability.
âœ… Combine USER_SOURCE, USER_DEPENDENCIES, and USER_ARGUMENTS for deep static analysis.
âœ… Apply PL/Scope for semantic-level insights (identifier usage, declaration tracking).
âœ… Follow best practices:

Avoid direct SQL in business logic (centralize via _API packages).

Avoid OUT/IN OUT parameters in functions.

Enable compiler optimizations and warnings.
âœ… Treat the data dictionary as a living code analysis engine.
